/*-------------------------------------------------------------------------
    String+Char.swift -- String/Character extensions
    Compiler Generator Coco/R
    Copyright (c) by Michael Griebling

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

public extension String {
	
	// Extensions to make it easier to work with C-style strings
	
    public subscript (n: Int) -> Character {
        get {
            let s = self.index(self.startIndex, offsetBy: n)
            if s < self.endIndex {
                return self[s]
            }
            return "\0"
        }
        set {
            // Strings are immutable so this gets messy and is probably not very efficient
            let s = self.index(self.startIndex, offsetBy: n)
            if s < self.endIndex {
                self = self.replacingCharacters(in: s...s, with: String(newValue))
            }
        }
    }
	
	public func stringByTrimmingTrailingCharactersInSet (_ characterSet: CharacterSet) -> String {
		if let rangeOfLastWantedCharacter = self.rangeOfCharacter(from: characterSet.inverted, options:.backwards) {
			return String(self[...rangeOfLastWantedCharacter.upperBound])
		}
		return ""
	}
    
    public func substring (_ from: Int, _ length: Int) -> String {
        let str : NSString = self as NSString
        return str.substring(with: NSMakeRange(from, length))
    }
    
    public func trim() -> String {
        return self.trimmingCharacters(in: CharacterSet.whitespaces)
    }
	
}

public extension Character {

    public var unicodeValue : Int { return Int(unicodeScalar.value) }
    public var unicodeScalar : UnicodeScalar { return String(self).unicodeScalars.first ?? "\0" }
    
    public func isLetter() -> Bool { return CharacterSet.letters.contains(self.unicodeScalar) }
    public func isAlphanumeric() -> Bool { return CharacterSet.alphanumerics.contains(self.unicodeScalar) }
    
    public var lowercase : Character { return String(self).lowercased().first! }
    public var uppercase : Character { return String(self).uppercased().first! }
	
    init(_ int: Int) { self = Character(UnicodeScalar(int) ?? UnicodeScalar(0)!) }
	
    public func add (_ n: Int) -> Character { return Character(self.unicodeValue + n) }
	
}

func == (l: Int, r: Character) -> Bool { return l == r.unicodeValue }
func == (l: Character, r: Int) -> Bool { return r == l }
func != (l: Int, r: Character) -> Bool { return l != r.unicodeValue }
func != (l: Character, r: Int) -> Bool { return r != l }
func + (c: Character, inc: Int) -> Character { return c.add(inc) }
func - (c: Character, inc: Int) -> Character { return c.add(-inc) }
func - (c: Character, inc: Character) -> Int { return c.add(-inc.unicodeValue).unicodeValue }
func += (c: inout Character, inc: Int) { c = c + inc }
func -= (c: inout Character, inc: Int) { c = c - inc }
postfix func -- (c: Character) -> Character { return c - 1 }
postfix func ++ (c: Character) -> Character { return c + 1 }
